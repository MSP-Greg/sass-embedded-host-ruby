# frozen_string_literal: true

require 'json'
require 'open-uri'
require 'open3'
require 'rake/clean'

task default: %i[install clean]

task install: %w[sass_embedded embedded_sass_pb.rb]

CLEAN.include %w[protoc.exe *.proto *.tar.gz *.zip]

CLOBBER.include %w[sass_embedded embedded_sass_pb.rb]

file 'protoc.exe' do |t|
  fetch(ENV.fetch(t.name.upcase) { Configuration.default_protoc }, t.name)
  chmod 'a+x', t.name
end

file 'sass_embedded' do |t|
  archive = fetch(ENV.fetch(t.name.upcase) { Configuration.default_sass_embedded })
  unarchive archive
  rm archive
end

file 'embedded_sass.proto' => %w[sass_embedded] do |t|
  fetch(ENV.fetch('sass_embedded_protocol'.upcase) { Configuration.default_sass_embedded_protocol }, t.name)
end

rule '_pb.rb' => %w[.proto protoc.exe] do |t|
  sh './protoc.exe', '--ruby_out=.', t.source
end

# This is a FileUtils extension that defines several additional commands to be
# added to the FileUtils utility functions.
module FileUtils
  def unarchive(archive, dest = '.')
    case archive.downcase
    when ->(name) { name.include?('.tar.') || name.end_with?('.tar') }
      mkdir_p dest
      sh 'tar', '-vxC', dest, '-f', archive
    when ->(name) { name.end_with?('.zip') }
      if Gem.win_platform?
        sh 'powershell', '-File', 'unzip.ps1', '-Archive', archive, '-DestinationPath', dest
      else
        sh 'unzip', '-od', dest, archive
      end
    else
      raise "Unknown archive format #{archive}"
    end
  end

  def fetch(uri_or_path, dest = nil)
    begin
      uri = URI.parse(uri_or_path)
      path = URI::DEFAULT_PARSER.unescape(uri.path)
      if uri.instance_of?(URI::File) || uri.instance_of?(URI::Generic)
        path = path.delete_prefix('/') if Gem.win_platform? && !File.file?(path)
        raise unless File.file?(path)
      end
    rescue StandardError
      raise unless File.file?(uri_or_path)

      uri = nil
      path = uri_or_path
    end

    dest = File.basename(path) if dest.nil?

    if uri.nil? || uri.instance_of?(URI::File) || uri.instance_of?(URI::Generic)
      cp path, dest
    elsif uri.respond_to?(:open)
      Rake.rake_output_message "curl -fsSLo #{dest} -- #{uri}" if Rake::FileUtilsExt.verbose_flag
      unless Rake::FileUtilsExt.nowrite_flag
        uri.open do |stream|
          File.binwrite(dest, stream.read)
        end
      end
    else
      raise
    end

    dest
  rescue StandardError
    raise "Failed to fetch #{uri_or_path}"
  end
end

# The {Configuration} module.
module Configuration
  module Platform
    OS = case RbConfig::CONFIG['host_os'].downcase
         when /darwin/
           'darwin'
         when /linux/
           'linux'
         when *Gem::WIN_PATTERNS
           'windows'
         else
           RbConfig::CONFIG['host_os'].downcase
         end

    ARCH = case RbConfig::CONFIG['host_cpu'].downcase
           when /amd64|x86_64|x64/
             'x86_64'
           when /i\d86|x86|i86pc/
             'i386'
           when /arm64|aarch64/
             'aarch64'
           when /^arm/
             # Ruby before 3.0 reports "arm" instead of "arm64" as host_cpu on darwin
             OS == 'darwin' ? 'aarch64' : 'arm'
           else
             RbConfig::CONFIG['host_cpu']
           end
  end

  private_constant :Platform

  class << self
    def default_sass_embedded
      repo = 'sass/dart-sass-embedded'

      spec = JSON.parse(File.read(File.absolute_path('package.json', __dir__)))

      tag_name = spec['dependencies']['sass-embedded']

      os = case Platform::OS
           when 'darwin'
             'macos'
           when 'linux'
             'linux'
           when 'windows'
             'windows'
           else
             raise release_asset_not_available_error(repo, tag_name)
           end

      arch = case Platform::ARCH
             when 'x86_64'
               'x64'
             when 'i386'
               'ia32'
             when 'aarch64'
               Platform::OS == 'darwin' ? 'x64' : 'arm64'
             else
               raise release_asset_not_available_error(repo, tag_name)
             end

      ext = case os
            when 'windows'
              'zip'
            else
              'tar.gz'
            end

      "https://github.com/#{repo}/releases/download/#{tag_name}/sass_embedded-#{tag_name}-#{os}-#{arch}.#{ext}"
    end

    def default_protoc
      repo = 'protocolbuffers/protobuf'

      version = Gem::Dependency.new('google-protobuf').to_spec.version

      tag_name = "v#{version}"

      os = case Platform::OS
           when 'darwin'
             'osx'
           when 'linux'
             'linux'
           when 'windows'
             'windows'
           else
             raise release_asset_not_available_error(repo, tag_name)
           end

      arch = case Platform::ARCH
             when 'x86_64'
               'x86_64'
             when 'i386'
               'x86_32'
             when 'aarch64'
               'aarch_64'
             else
               raise release_asset_not_available_error(repo, tag_name)
             end

      "https://repo.maven.apache.org/maven2/com/google/protobuf/protoc/#{version}/protoc-#{version}-#{os}-#{arch}.exe"
    end

    def default_sass_embedded_protocol
      stdout, stderr, status = Open3.capture3(
        File.absolute_path("sass_embedded/dart-sass-embedded#{Gem.win_platform? ? '.bat' : ''}", __dir__), '--version'
      )
      raise stderr unless status.success?

      tag_name = JSON.parse(stdout)['protocolVersion']
      "https://github.com/sass/embedded-protocol/raw/#{tag_name}/embedded_sass.proto"
    end

    private

    def release_asset_not_available_error(repo, tag_name)
      NotImplementedError.new(
        "Release asset for #{Platform::OS} #{Platform::ARCH} "\
        "not available at https://github.com/#{repo}/releases/tag/#{tag_name}"
      )
    end
  end
end
